https://ctftime.org/event/2423

# Signal (rev)

Can you catch the right signals for the flag?

The flag length is 32 bytes (without the flag format).

Flag format: TFCCTF{flag}

## Analysis

`main` @ `0x18b5`
- Verifies that the user has supplied a value in `argv[1]`
- Set's `char* gInput` equal to `&argv[1]`
- Registers a range of custom signal handlers
- Performs an invalid write to `0x1337` to trigger a sigsegv

`HandleSigsegv` @ `0x128d`
- Checks `gInput[0:4]` matches `b11e8`

`HandleSigill` @ `0x145b`
- Checks `gInput[0xa:0xe]` matches `b27dc`

`HandleSigalarm` @ `0x1556`
- Checks `gInput[0xf:0x13]` matches `f82e7`

`HandleSigpipe` @ `0x167d`
- Checks `gInput[0x14:0x18]` matches `0c4ba`

`HandleSigabrt` @ `0x1764`
- Checks `gInput[0x19:0x1f]` matches `d63a3eb`

`GenerateChallenge` @ `0x11f9`
- Creates an alphabet on the stack
- Seeds `srand` with `time(0)` or the current time
- Generates 32 bytes using `rand` and the alphabet

## Solution

From static analysis of the signal handlers we can determine 27 bytes of the flag:

`b11e8?????b27dcf82e70c4bad63a3eb`

If we presume that the author used the code in `GenerateChallenge` to compute the expected flag we can simply roll back from `time(0)` until we generate a flag which starts and ends with the known elements of the flag recovered during static analysis.

During the development of this solution I had endian swapped the alphabet by mistake. This meant that I did not quickly find a solution and assumed I would have to go back in time a long way. As a result I built a multi-process solver in C despite this being massive overkill.

```c
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <pthread.h>

#define NUM_WORKERS (16)

void* worker(void *arg) {
    time_t start = (time_t)arg;
    char cmd[512];
    sprintf(cmd, "./worker %ld %d", start, NUM_WORKERS);
    int rc = system(cmd);
    (void)rc;
    pthread_exit(0);
}

int main(int argc, char** argv) {
    pthread_t threads[NUM_WORKERS];

    time_t now = time(0);

    for (int i = 0; i < NUM_WORKERS; i++) {
        pthread_create(&threads[i], 0, worker, (void*)(now - i));
    }

    for (int i = 0; i < NUM_WORKERS; i++) {
        pthread_join(threads[i], 0);
    }

    return 0;
}
```

```c
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <string.h>

char const* alpha = "abcdef0123456789";

int main(int argc, char** argv) {
    char flag[32];
    time_t start = (time_t)atoi(argv[1]);
    int step = atoi(argv[2]);
    time_t now = start;

    printf("start: %ld step: %d\n", start, step);

    for ( ; ; ) {
        srand(now);
        for (int i = 0; i < 32; i++)
            flag[i] = alpha[rand() & 0xf];
        if (memcmp(flag, "b11e8", 5) == 0) {
            if (memcmp(&flag[10], "b27dc", 5) == 0) {
                printf("[%s]\n", flag);
                if (memcmp(&flag[10], "b27dcf82e70c4bad63a3eb", 22) == 0) {
                    printf("%s\n", flag); // TFCCTF{b11e807f65b27dcf82e70c4bad63a3eb}
                    break;
                }
            }
        }
        now -= step;
    }
    return 0;
}
```

### pin

As a fun aside you can compute all of the flag, except the five 0s, using pin's `inscount2_mt.so`.

I used a template generated by `ret` https://github.com/rerrorctf/ret?tab=readme-ov-file#-inscount.

```python
#!/usr/bin/env python3

import string
from pwn import *

PIN             = "/opt/pin/pin"
INSCOUNT2_MT_SO = "/opt/pin/source/tools/SimpleExamples/obj-intel64/inscount2_mt.so"
BINARY          = "./signal"

flag = b""

while True:
	highest_count = 0
	best_byte = b"\x00"
	for c in "10fedcba98765432":
		b = c.encode()
		with process(argv=[PIN, "-t", INSCOUNT2_MT_SO, "--", BINARY, flag + b], level="CRITICAL") as p:
			lines = p.recvall().split(b"\n")

			count = 0
			for line in lines:
				if b"Count[" in line:
					count += int(line.split(b" = ")[1])

			if count > highest_count:
				highest_count = count
				best_byte = b
	flag += best_byte
	log.success(flag.decode()) # b11e800000b27dcf82e70c4bad63a3eb
```

## Flag
`TFCCTF{b11e807f65b27dcf82e70c4bad63a3eb}`

smiley 2024/08/03
