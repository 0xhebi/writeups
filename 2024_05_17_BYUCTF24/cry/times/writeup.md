https://ctftime.org/event/2252/

# Times (Crypto)

It's just multiplication... right?

## Background

### times.txt

We are given the following information in the file `times.txt`:

```
Curve:  y^2 = x**3 + 13x + 245 % 335135809459196851603485825030548860907
Point:  (14592775108451646097, 237729200841118959448447480561827799984)
{'ciphertext': b'SllGMo5gxalFG9g8j4KO0cIbXeub0CM2VAWzXo3nbIxMqy1Hl4f+dGwhM9sm793NikYA0EjxvFyRMcU2tKj54Q==', 'iv': b'MWkMvRmhFy2vAO9Be9Depw=='}
```

`Curve` is an equation for an elliptic curve of the form:

`y^2 = x**3 + ax + b mod p`

The equation coefficients and the prime are given such that `a` is `13`, `b` is `245` and `p` is `335135809459196851603485825030548860907`.

`Point` is a point on the curve used to generate a cyclic group.

`ciphertext` is base64 encoded encrypted data. We can safely assume that this contains the flag.

We are given an `iv` was presumably used during the encryption and can likely be used again in the decryption.

### mul_safe.py

We are given the following code in the file `mul_safe.py`:

```
import hashlib
from Crypto.Cipher import AES 
from Crypto.Util.Padding import pad, unpad
from ellipticcurve import * # I'll use my own library for this
from base64 import b64encode
import os
from Crypto.Util.number import getPrime

def encrypt_flag(shared_secret: int, plaintext: str):
    iv = os.urandom(AES.block_size)

    #get AES key from shared secret
    sha1 = hashlib.sha1()
    sha1.update(str(shared_secret).encode('ascii'))
    key = sha1.digest()[:16]

    #encrypt flag
    plaintext = pad(plaintext.encode('ascii'), AES.block_size)
    cipher = AES.new(key, AES.MODE_CBC, iv)
    ciphertext = cipher.encrypt(plaintext)

    return { "ciphertext" : b64encode(ciphertext), "iv" : b64encode(iv) }
    
def main():
    the_curve = EllipticCurve(13, 245, getPrime(128))
    start_point = None
    while start_point is None:
        x = getPrime(64)
        start_point = the_curve.point(x)
    print("Curve: ", the_curve)
    print("Point: ", start_point)
    new_point = start_point * 1337

    flag = "byuctf{REDACTED}"
    print(encrypt_flag(new_point.x, flag))

if __name__ == "__main__":
    main()
```

We can see that a point on the curve is selected by randomly choosing a base and then performing elliptic curve point multiplication `1337` times. This is unusual, as normally the base point is public and the scalar used is kept private, and could allow us to recover the value of `new_point`.

The rest of the code:
- Generates the `16` byte initialization vector, or IV, using `os.urandom`.
- Takes the abscissa of the computed point and hashes it with sha1 keeping only the lower `16` bytes.
- The `16` byte hash is then used as the key for AES CBC encryption along with the random IV and the plaintext.

### Elliptic Curve Point Addition and Multiplication Background

You can safely skip this section if you know how this works already.

In cryptography typically elliptic curves use two finite fields. Firstly there is the prime field over which the curve itself is defined and secondly there is the cyclic group that is generated by repeated application of the group operator to a given base point or generator point.

When dealing with point addition and point multiplication it is within this second group that we are working.

Unlike regular addition, or regular modular addition, elliptic curve point addition is defined as the reflection of the intersection of the tangent between the two points in question.

Once we have defined this group operation, in terms of reflecting the intersection of the tangent, we can generate the elements of the group through successive application of the group operation to the generator point.

In order to achieve multiplication we simply perform this group operation ( elliptic curve point addition ) multiple times.

See the below code for an example of how this could be implemented.

For more information ( and some visuals ) see https://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication

## Solution

Considering that we know:
- The curve equation
- The starting point on the curve
- The scalar used to select a new point on the curve
- The value of the IV and the ciphertext

We can:
- Recompute the point on the curve
- Recompute the AES key
- Decrypt the ciphertext using the recomputed AES key and the provided IV

### Putting It All Together

```
def inverse(x, n):
    return pow(x, -1, n)

def point_addition_slope(P, Q, p):
    y = Q[1] - P[1]
    x = Q[0] - P[0]
    x_inverse = inverse(x, p)
    return (y * x_inverse) % p

def point_doubling_slope(P, a, p):
    y = (3 * P[0] * P[0]) + a % p
    x = 2 * P[1] % p
    x_inverse = inverse(x, p)
    return (y * x_inverse) % p

def point_addition(P, Q, a, p):
    if P != Q:
        s = point_addition_slope(P, Q, p)
    else:
        s = point_doubling_slope(P, a, p)
    x = ((s * s) - P[0] - Q[0]) % p
    y = ((s * (P[0] - x)) - P[1]) % p
    return (x, y)

def point_multiplication(P, d, a, p):
    T = P
    for i in range(d.bit_length() - 2, -1, -1):
        T = point_addition(T, T, a, p)
        if (d >> i) & 1:
            T = point_addition(T, P, a, p)
    return T

P = (14592775108451646097, 237729200841118959448447480561827799984)
a = 13
p = 335135809459196851603485825030548860907

T = point_multiplication(P, 1337, a, p)

import hashlib
sha1 = hashlib.sha1()
sha1.update(str(T[0]).encode('ascii'))
key = sha1.digest()[:16]
print(key.hex())
```

This prints the key which is `c80b20ed6e4752748b45f83b6f3ed9f8`.

I decided it would be easier to use https://gchq.github.io/CyberChef to perform the AES decryption.

Here is a link to the recipe I used:

```
https://gchq.github.io/CyberChef/#recipe=From_Base64('A-Za-z0-9%2B/%3D',true,false)AES_Decrypt(%7B'option':'Hex','string':'c80b20ed6e4752748b45f83b6f3ed9f8'%7D,%7B'option':'Base64','string':'MWkMvRmhFy2vAO9Be9Depw%3D%3D'%7D,'CBC','Raw','Raw',%7B'option':'Hex','string':''%7D,%7B'option':'Hex','string':''%7D)&input=U2xsR01vNWd4YWxGRzlnOGo0S08wY0liWGV1YjBDTTJWQVd6WG8zbmJJeE1xeTFIbDRmK2RHd2hNOXNtNzkzTmlrWUEwRWp4dkZ5Uk1jVTJ0S2o1NFE9PQ
```

Which is roughly the same as:

`AES_CBC_DECRYPT(key=FromHex(c80b20ed6e4752748b45f83b6f3ed9f8), iv=Base64Decode(MWkMvRmhFy2vAO9Be9Depw==), ciphertext=Base64Decode(SllGMo5gxalFG9g8j4KO0cIbXeub0CM2VAWzXo3nbIxMqy1Hl4f+dGwhM9sm793NikYA0EjxvFyRMcU2tKj54Q==))`

## Flag
`byuctf{mult1pl1c4t10n_just_g0t_s0_much_m0r3_c0mpl1c4t3d}`
