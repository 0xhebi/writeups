https://ctftime.org/event/2479

# maybe Checker (REV)

## Analysis

`FUN_00401180`:
- This function use a psudo-random process to choose a function from a table to check a part of the flag
    - Input which satisfies all of the functions in the table is likely to be the flag
- The table format is 9 bytes per entry where:
    - The first byte is the offset into the flag whose address is passed into the function
    - The next 8 bytes represent the function address

`FUN_00401210`:
- A special dispatch table target that checks that the flag has the proper format
    - i.e. `bwctf{.+}`
- From this we can also get the length of the flag as 48 chars by checking the offset which `}` is at

`FUN_00401240`:
- A special dispatch table target that checks that the flag contains `-`s at the right places

`FUN_00401270` => `FUN_00401770`:
- These functions form the rest of the dispatch table targets
- Each performs a check against some constraint on the input

## Solution

1) Setup z3 to use 48 `BitVec(..., 32)`s
    - The reason we use 32 rather than 8 is that some of the constraints check the results of additions and multiplications that are done with 32 bit values
    - We constrain the each one as follows `inp[i] & 0xffffff80) == 0` to ensure that only values `0->0x7f` are considered
2) For each function specify the constraint
    - Take care to offset the input using the value from the table that used to offset the input prior to calling the function

```python
#!/usr/bin/env python3

from z3 import *

N = 48

inp = []
for i in range(N):
    inp.append(BitVec(f"{i}", 32))

s = Solver()

for i in range(N):
    s.add((inp[i] & 0xffffff80) == 0)

s.add(inp[0] == 0x62) # FUN_00401210 0x00
s.add(inp[1] == 0x77)
s.add(inp[2] == 0x63)
s.add(inp[3] == 0x74)
s.add(inp[4] == 0x66)
s.add(inp[5] == 0x7b)
s.add(inp[47] == 0x7d)
s.add(inp[3 + 0x08] == 0x2d) # FUN_00401240 0x08
s.add(inp[9 + 0x08] == 0x2d)
s.add(inp[0xf + 0x08] == 0x2d)
s.add(inp[0x15 + 0x08] == 0x2d)
s.add(inp[0x1b + 0x08] == 0x2d)
s.add(inp[0x21 + 0x08] == 0x2d)
s.add(inp[0xd + 0x05] < inp[0xe + 0x05]) # FUN_00401270 0x05
s.add((inp[0x1e + 0x04] ^ inp[2 + 0x04]) == 0x64) # FUN_00401280 0x04
s.add(inp[0xe + 0x04] < inp[0x11 + 0x04]) # FUN_00401290 0x04
s.add((inp[0x2 + 0x22] * inp[0x8 + 0x22]) == 0x1de6) # FUN_004012a0 0x22
s.add(inp[0x5 + 0x04] < inp[0x20 + 0x04]) # FUN_004012c0 0x04
s.add(inp[0xc + 0x07] > inp[0x1e + 0x07]) # FUN_004012d0 0x07
s.add(inp[0xc + 0x07] == inp[0x1f + 0x07]) # FUN_004012e0 0x07
s.add((inp[0 + 0x0d] * inp[0xe + 0x0d]) == 0xd59) # FUN_004012f0 0x0d
s.add(inp[1 + 0x17] > inp[3 + 0x17]) # FUN_00401310 0x17
s.add(inp[7 + 0x17] < inp[0xd + 0x17]) # FUN_00401320 0x17
s.add(inp[0x8 + 0x0b] > inp[0x15 + 0x0b]) # FUN_00401330 0x0b
s.add((inp[0x1c + 0x06] + inp[0x22 + 0x06]) == 0x67) # FUN_00401340 0x06
s.add((inp[0xb + 0x09] ^ inp[0xa + 0x09]) == 0x66) # FUN_00401360 0x09
s.add((inp[0x13 + 0x13] ^ inp[1 + 0x13]) == 0x66) # FUN_00401370 0x13
s.add((inp[0xf + 0x16] + inp[0x17 + 0x16]) == 0x85) # FUN_00401380 0x16
s.add((inp[0xa + 0x02] + inp[0x29 + 0x02]) == 0x92) # FUN_004013a0 0x02
s.add((inp[0x4 + 0x6] + inp[0x28 + 0x6]) == 0x7e) # FUN_004013c0 0x06
s.add(inp[0x7 + 0x15] > inp[0x17 + 0x15]) # FUN_004013e0 0x15
s.add(inp[0x2 + 0x06] < inp[0x20 + 0x6]) # FUN_004013f0 0x06
s.add((inp[0xd + 0x15] ^ inp[0x5 + 0x15]) == 0x61) # FUN_00401400 0x15
s.add((inp[0x1a + 0x10] ^ inp[0x12 + 0x10]) == 0x65) # FUN_00401410 0x10
s.add(inp[0x2 + 0x6] < inp[0x1c + 0x6]) # FUN_00401420 0x06
s.add(inp[0 + 0x8] == inp[0xa + 0x8]) # FUN_00401430 0x08
s.add((inp[0xa + 0x2] * inp[0x13 + 0x2]) == 0x1a2b) # FUN_00401440 0x02
s.add((inp[0x12 + 0x0d] ^ inp[0xc + 0xd]) == 0x7b) # FUN_00401460 0x0d
s.add((inp[0xe + 0x2] ^ inp[0x4 + 0x2]) == 0x15) # FUN_00401470 0x02
s.add(inp[0x5 + 0xa] < inp[0x1e + 0xa]) # FUN_00401480 0x0a
s.add((inp[0x16 + 0x9] ^ inp[0x15 + 0x9]) == 0xe) # FUN_00401490 0x09
s.add((inp[0xd + 0xc] * inp[0x21 + 0xc]) == 0x10ef) # FUN_004014a0 0x0c
s.add((inp[0x1b + 0x4] ^ inp[0xc + 0x4]) == 0xa) # FUN_004014c0 0x04
s.add((inp[0x16 + 0x18] ^ inp[0x2 + 0x18]) == 0x1c) # FUN_004014d0 0x18
s.add(inp[0x15 + 0x00] > inp[0x2a + 0x00]) # FUN_004014e0 0x00
s.add(inp[0xb + 0x3] > inp[0x1e + 0x3]) # FUN_004014f0 0x03
s.add(inp[0xe + 0x1] == inp[0x1f + 0x1]) # FUN_00401500 0x01
s.add((inp[0xe + 0x8] * inp[0x12 + 0x8]) == 0x10a8) # FUN_00401510 0x08
s.add(inp[0xf + 0x3] < inp[0x13 + 0x3]) # FUN_00401530 0x03
s.add((inp[0xe + 0x00] + inp[0xf + 0x00]) == 0x84) # FUN_00401540 0x00
s.add((inp[0x5 + 0x5] * inp[0x1c + 0x5]) == 0xf00) # FUN_00401560 0x05
s.add((inp[0x2 + 0x16] + inp[0xc + 0x16]) == 0x87) # FUN_00401580 0x16
s.add((inp[0xe + 0x8] + inp[0x11 + 0x8]) == 0x67) # FUN_004015a0 0x08
s.add((inp[0x1 + 0x8] * inp[0xc + 0x8]) == 0xd59) # FUN_004015c0 0x08
s.add(inp[0x8 + 0x0b] > inp[0x23 + 0xb]) # FUN_004015e0 0x0b
s.add((inp[0x4 + 0x6] + inp[0x16 + 0x6]) == 0x84) # FUN_004015f0 0x06
s.add((inp[0x19 + 0x2] + inp[0x1c + 0x2]) == 0x89) # FUN_00401610 0x02
s.add((inp[0x5 + 0x09] ^ inp[0x3 + 0x9]) == 0x19) # FUN_00401630 0x09
s.add((inp[0x13 + 1] * inp[0x2a + 1]) == 0xdbf) # FUN_00401640 0x01
s.add((inp[0x4 + 0x1c] * inp[0x6 + 0x1c]) == 0x990) # FUN_00401660 0x1c
s.add((inp[0xe + 0x1] + inp[0x26 + 0x1]) == 0x78) # FUN_00401680 0x01
s.add((inp[0x6 + 0x7] * inp[0x17 + 0x7]) == 0xdf2) # FUN_004016a0 0x07
s.add((inp[1 + 0x17] + inp[0x15 + 0x17]) == 0x9a) # FUN_004016c0 0x17
s.add((inp[0xb + 0x11] ^ inp[0x3 + 0x11]) == 0x67) # FUN_004016e0 0x11
s.add((inp[0x8 + 0xa] + inp[0xf + 0xa]) == 0x64) # FUN_004016f0 0x0a
s.add((inp[0x1 + 0x6] * inp[0xf + 0x6]) == 0x1773) # FUN_00401710 0x06
s.add(inp[0x8 + 0x11] == inp[0x11 + 0x11]) # FUN_00401730 0x11
s.add((inp[0x3 + 0x6] ^ inp[0x2 + 0x6]) == 0x72) # FUN_00401740 0x06
s.add((inp[0x1b + 0x9] ^ inp[0xa + 0x9]) == 0xc) # FUN_00401750 0x9
s.add((inp[0x8 + 0x6] ^ inp[0x4 + 0x6]) == 0x64) # # FUN_00401760 0x06
s.add((inp[0x15 + 0xa] + inp[0x24 + 0xa]) == 0x96) # FUN_00401770 0x0a

s.check()
model = s.model()

flag = ""
for i in range(N):
    flag += chr(int(str(model[inp[i]])))

print(flag) # bwctf{WE1C0-M3T0B-1U3W4-T3RCT-FH0P3-Y0UH4-VEFUN}
```

## Flag
`bwctf{WE1C0-M3T0B-1U3W4-T3RCT-FH0P3-Y0UH4-VEFUN}`

smiley 2024/10/13
